{"version":3,"sources":["meteor://ðŸ’»app/packages/kadira_debug/lib/utils.js","meteor://ðŸ’»app/packages/kadira_debug/lib/client/utils.js","meteor://ðŸ’»app/packages/kadira_debug/lib/client/store.js","meteor://ðŸ’»app/packages/kadira_debug/lib/client/providers/blaze.js","meteor://ðŸ’»app/packages/kadira_debug/lib/client/providers/flow_router.js","meteor://ðŸ’»app/packages/kadira_debug/lib/client/providers/iron_router.js","meteor://ðŸ’»app/packages/kadira_debug/lib/client/providers/ddp.js","meteor://ðŸ’»app/packages/kadira_debug/lib/client/providers/hcr.js","meteor://ðŸ’»app/packages/kadira_debug/lib/client/providers/system.js","meteor://ðŸ’»app/packages/kadira_debug/lib/client/connect.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+F;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gG;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iG;;;;;;;;;;;;;;;;;;ACzQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gG;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gG;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gG;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iG;;;;;;;;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gG;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gG;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gG","file":"/packages/kadira_debug.js","sourcesContent":["Utils = Utils || {};\n\nUtils.getAppEnv = function() {\n  var env = 'development';\n  if(!Package['kadira:runtime-dev']) {\n    env = 'production';\n  }\n  return env;  \n};","Utils = Utils || {};\n\nUtils.findBlazeViewName = function(view) {\n  var name = view.name;\n  // if this is a template we can simply send the name\n  if(view.template) {\n    return name;\n  }\n\n  var parent = view.parentView;\n  // if not, let's try to find out a name which is easy to debug\n  for(var lc=0; lc<5; lc++) {\n    if(!parent) {\n      break;\n    }\n\n    name = parent.name + '.' + name;\n    // if we found the parent, we are good to go\n    if(parent.template) {\n      break;\n    }\n\n    // try to get the next parent\n    parent = parent.parentView;\n  }\n\n  return name;\n};\n\n// This is a simple helper to override namespaces in our code\n// Buy using this way, it helps us to write unit test for our overriden code\n// @param namespace - this is the Object used for overriding\n// @param funcName - name of the function in this namespace\n// @param generator - function which creates the overriding logic\n// eg:-\n//    var genFunction = function(original) {\n//      return function(view, which) {\n//        var name = Utils.findBlazeViewName(view);\n//        var done = StoreManager.trackActivity('view.' + which, name);\n//        var response = original.call(this, view, which);\n//        done();\n//        return response;\n//      };\n//    };\n//    Utils.override(Blaze, '_fireCallbacks', genFunction);\n\nUtils.override = function(namespace, funcName, generator) {\n  var original = namespace[funcName];\n  namespace[funcName] = generator(original);\n};","var isPerformanceExists = typeof window.performance !== 'undefined';\n\nStore = function(options) {\n  var self = this;\n  options = options || {};\n\n  this._serverPushInterval = options.serverPushInterval || 1000;\n  this.currentDataBlocks = {};\n  this._oldDataBlock = null;\n  this._browserId = null;\n  this._clientId = null;\n  this._startFns = [];\n  this._beforePushFns = [];\n  this._beforeBlockCloseFns = [];\n  // Random id for this session\n  this._sessionKey = Random.id();\n\n  this._yesTracking = new Meteor.EnvironmentVariable();\n};\n\nStore.prototype.onTracking = function(fn) {\n  return this._yesTracking.withValue(true, fn);\n};\n\nStore.prototype.start = function(browserId, clientId) {\n  if(!browserId || !clientId) {\n    throw new Error(\"browserId or clientId can't be empty.\");\n  }\n\n  // if Store already started\n  // return without do anything\n  if(this._isStarted()) {\n    return;\n  }\n\n  this.stop();\n  this._browserId = browserId;\n  this._clientId = clientId;\n  this._pushToServer();\n\n  // trigger startfns\n  this._runCallbacks(this._startFns);\n  this._startFns = [];\n};\n\nStore.prototype.stop = function() {\n  this._browserId = null;\n  this._clientId = null;\n  clearTimeout(this._pushToServerHandler);\n  this._pushToServerHandler = null;\n};\n\nStore.prototype.now = function() {\n  if (isPerformanceExists) {\n    return performance.now();\n  }\n\n  return (new Date()).getTime();\n};\n\nStore.prototype._getCurrentDataBlock = function(timestamp) {\n  var startTimeInSec = this._normalizeDateToSec(timestamp);\n  var block = this.currentDataBlocks[startTimeInSec];\n  if(!block) {\n    if(this._oldDataBlock) {\n      this._closeBlock(this._oldDataBlock);\n    }\n    block = this.currentDataBlocks[startTimeInSec] = this._buildDataBlock(startTimeInSec);\n    this._oldDataBlock = block;\n  }\n\n  return block;\n};\n\nStore.prototype.trackEvent = function(type, data, startTime) {\n  if(!this._isStarted()) {\n    return function() {};\n  }\n\n  startTime = startTime || Date.now();\n  var currentDataBlock = this._getCurrentDataBlock(startTime);\n\n  var item = [startTime, type, data];\n  currentDataBlock.events.push(item);\n};\n\nStore.prototype.trackActivity = function(type, name) {\n  var self = this;\n  if(!self._isStarted()) {\n    return function() {};\n  }\n\n  var alreadyTracking = false;\n  if(self._yesTracking.get()) {\n    alreadyTracking = true;\n  }\n\n  var start = self.now();\n  var marked = false;\n  function done() {\n    if(marked) {\n      return;\n    }\n    var elapsedTime = (alreadyTracking)? 0 : self.now() - start;\n    self._updateActivity(type, name, elapsedTime);\n    marked = true;\n  }\n\n  return done;\n};\n\nStore.prototype.trackGuage = function(key, value, options) {\n  if(!this._isStarted()) {\n    return function() {};\n  }\n\n  options = options || {};\n  startTime = options.startTime || (new Date()).getTime();\n  var currentDataBlock = this._getCurrentDataBlock(startTime);\n\n  currentDataBlock.gauges[key] = currentDataBlock.gauges[key] || 0;\n  if(options.sum) {\n    currentDataBlock.gauges[key] += value;\n  } else {\n    currentDataBlock.gauges[key] = value;\n  }\n};\n\n/*\n  Tracks time related metrics for DDP messages\n  (but possible for others as well)\n\n  @param type - type of the message (pubsub, method)\n  @param id - id of the message\n  @param event - event we are tracking the time (eg:- start, end)\n  @timestamp [optional] - timestamp of the event in milliseconds\n  @info [optional] - an object containing some special information\n*/\nStore.prototype.trackTime = function(type, id, event, timestamp, info) {\n  if(typeof timestamp === \"object\") {\n    info = timestamp;\n    timestamp = null;\n  }\n\n  timestamp = timestamp || Date.now();\n\n  var currentDataBlock = this._getCurrentDataBlock(timestamp);\n\n  var item = {\n    type: type,\n    id: id,\n    event: event,\n    timestamp: timestamp\n  };\n\n  if(info) {\n    item.info = info;\n  }\n\n  currentDataBlock.times.push(item);\n};\n\nStore.prototype._buildDataBlock = function(timestamp) {\n  var block = {\n    timestamp: timestamp,\n    events: [],\n    activities: {},\n    gauges: {},\n    times: [],\n    // Used to identify a unique session. This does not prevent the key\n    // between HCR.\n    sessionKey: this._sessionKey\n  };\n\n  return block;\n};\n\nStore.prototype._updateActivity = function(type, name, elapsedTime) {\n  var key = type + \"::\" + name;\n  var currentDataBlock = this._getCurrentDataBlock(Date.now());\n\n  var activity = currentDataBlock.activities[key];\n  if(!activity) {\n    activity = currentDataBlock.activities[key] = {\n      type: type,\n      name: name,\n      count: 0,\n      elapsedTime: 0\n    };\n  }\n\n  activity.count++;\n  activity.elapsedTime += elapsedTime;\n};\n\nStore.prototype._pushToServer = function pushToServer() {\n  var self = this;\n  if(!self._clientId) {\n    return;\n  }\n\n  // running flush callbacks\n  this._runCallbacks(this._beforePushFns);\n\n  var blocks = this.currentDataBlocks;\n  this.currentDataBlocks = {};\n\n  _.each(blocks, function(block) {\n    if(!block.closed) {\n      self._closeBlock(block);\n    }\n\n    Meteor.call(\n      'kadira.debug.client.updateTimeline', self._browserId,\n      self._clientId, block\n    );\n  });\n\n  function runAgain() {\n    self._pushToServer();\n  }\n\n  this._pushToServerHandler = setTimeout(runAgain, this._serverPushInterval);\n};\n\nStore.prototype._closeBlock = function(block) {\n  this._runCallbacks(this._beforeBlockCloseFns, block);\n  block.closed = true;\n};\n\nStore.prototype.beforePush = function(fn) {\n  this._beforePushFns.push(fn);\n};\n\nStore.prototype.beforeBlockClose = function(fn) {\n  this._beforeBlockCloseFns.push(fn);\n};\n\nStore.prototype.startup = function(fn) {\n  if(this._browserId) {\n    fn();\n  } else {\n    this._startFns.push(fn);\n  }\n};\n\nStore.prototype._normalizeDateToSec = function(timestamp) {\n  var diff = timestamp % 1000;\n  return timestamp - diff;\n};\n\nStore.prototype._runCallbacks = function(callbacks) {\n  var args = _.toArray(arguments).slice(1);\n  _.each(callbacks, function(fn) {\n    fn.apply(null, args);\n  });\n};\n\nStore.prototype._isStarted = function() {\n  if(this._clientId) {\n    return true;\n  }\n};\n\nStoreManager = window.StoreManager = new Store();\n","BlazeProvider = {};\n\n// Events\nBlazeProvider.events = function(original) {\n  return function(dict) {\n    var self = this;\n    _.each(dict, function(fn, name) {\n      dict[name] = function() {\n        var that = this;\n        var args = arguments;\n        var info = {\n          name: name,\n          view: self.viewName\n        };\n        StoreManager.trackEvent('event', info);\n        return fn.apply(that, args);\n      };\n    });\n\n    return original.call(self, dict);\n  };\n};\n\nif (Package['templating']) {\n  var Template = Package['templating'].Template;\n  Utils.override(Template.prototype, 'events', BlazeProvider.events);\n}\n","FlowRouterProvider = {};\nFlowRouterProvider.track = function(flowRouter) {\n  var info = {\n    provider: 'flow-router'\n  };\n\n  flowRouter.triggers.enter([function(context) {\n    info.path = context.path;\n    StoreManager.trackEvent('route', info);\n  }]);\n};\n\nif(Package['kadira:flow-router']) {\n  var FlowRouter = Package['kadira:flow-router'].FlowRouter;\n  FlowRouterProvider.track(FlowRouter);\n}\n\nif(Package['kadira:flow-router-ssr']) {\n  var FlowRouter = Package['kadira:flow-router-ssr'].FlowRouter;\n  FlowRouterProvider.track(FlowRouter);\n}\n","IronRouterProvider = {};\nIronRouterProvider.track = function(ironRouter) {\n  ironRouter.onBeforeAction(function() {\n    var url = Tracker.nonreactive(function() {\n      return ironRouter.current().url;\n    });\n    var info = {\n      path: url,\n      provider: 'iron-router'\n    };\n    StoreManager.trackEvent('route', info);\n    this.next();\n  })\n};\n\nif(Package['iron:router']) {\n  IronRouterProvider.track(Package['iron:router'].Router);\n}\n","DDPProvider = {\n  ignoringMethods: {\n    \"kadira.debug.client.updateTimeline\": true\n  },\n  ignoringMethodIds: {}\n};\n\nvar conn = Meteor.connection;\n\n// watch incoming messages\nDDPProvider._livedata_data = function(original) {\n  var currentLiveUpdateMessageBlock = null;\n  var flushScheduleHandler = null;\n\n  // flush live updates just before sending data to the server\n  StoreManager.beforePush(flushLiveUpdates);\n\n  return function(msg) {\n    var info = {};\n    var eventName = null;\n\n    trackLiveUpdates(msg);\n\n    switch(msg.msg) {\n      case \"ready\": \n        eventName = \"ddp-ready\";\n        info.subs = msg.subs;\n        _.each(info.subs, function(sub) {\n          StoreManager.trackTime('pubsub', sub, 'ready');\n        });\n        break;\n      case \"updated\":\n        var methods = [];\n        // removing ignoring methods\n        _.each(msg.methods, function(id) {\n          if(DDPProvider.ignoringMethodIds[id]) {\n            if(--DDPProvider.ignoringMethodIds[id] === 0) {\n              delete DDPProvider.ignoringMethodIds[id];\n            }\n          } else {\n            methods.push(id);\n            StoreManager.trackTime('method', id, 'updated');\n          }\n        });\n\n        if(methods.length === 0) {\n          break;\n        }\n\n        eventName = \"ddp-updated\";\n        info.methods = methods;\n        break;\n    }\n\n    if(eventName) {\n      StoreManager.trackEvent(eventName, info);\n    }\n    return original.call(conn, msg);\n  };\n\n  function trackLiveUpdates(msg) {\n    if(msg.msg == \"added\" || msg.msg == \"removed\" || msg.msg == \"changed\") {\n      // decide whether to flush or not\n      // we don't need to flush if we are getting same type of message\n      // fortunately, DDP send similar messages together.\n      // so we can group them easily\n      var canFlush = \n        !currentLiveUpdateMessageBlock ||\n        currentLiveUpdateMessageBlock.type != msg.msg ||\n        currentLiveUpdateMessageBlock.collection != msg.collection;\n      if(canFlush) {\n        flushLiveUpdates();\n      }\n\n      // add the block for first time after reset when flushing\n      if(!currentLiveUpdateMessageBlock) {\n        currentLiveUpdateMessageBlock = {\n          type: msg.msg,\n          collection: msg.collection,\n          startTime: Date.now(),\n          count: 0,\n          lastUpdatedAt: Date.now(),\n          sampleMessages: [],\n        };\n      }\n\n      currentLiveUpdateMessageBlock.sampleMessages.push(msg);\n      // Only keep upto 5 ddp messages.\n      // This is to avoid sending too many data\n      // XXX: We may also need to check for the size of the individual\n      // message also\n      if(currentLiveUpdateMessageBlock.sampleMessages.length > 5) {\n        currentLiveUpdateMessageBlock.sampleMessages.shift();\n      }\n\n      // increment the block\n      currentLiveUpdateMessageBlock.count++;\n      currentLiveUpdateMessageBlock.lastUpdatedAt = Date.now();\n      // scheduleForFlush();\n    } else {\n      // flush tracking directly for other messages\n      flushLiveUpdates();\n    }\n  }\n\n  function flushLiveUpdates() {\n    if(!currentLiveUpdateMessageBlock) {\n      return;\n    }\n\n    var info = currentLiveUpdateMessageBlock;\n    var startAt = info.startTime;\n    StoreManager.trackEvent('live-updates', info, startAt);\n\n    // reset the current block\n    currentLiveUpdateMessageBlock = null;\n  }\n};\nUtils.override(conn, '_livedata_data', DDPProvider._livedata_data);\n\nDDPProvider._livedata_result = function(original) {\n  // XXX: Track result as an event\n  // It has the whether this message is an error or not\n  return function(msg) {\n    if(DDPProvider.ignoringMethodIds[msg.id]) {\n      if(--DDPProvider.ignoringMethodIds[msg.id] === 0) {\n        delete DDPProvider.ignoringMethodIds[msg.id];\n      }\n    } else {\n      StoreManager.trackTime('method', msg.id, 'result');\n    }\n\n    original.call(conn, msg);\n  };\n};\nUtils.override(conn, '_livedata_result', DDPProvider._livedata_result);\n\nDDPProvider._livedata_nosub = function(original) {\n  return function(msg) {\n    var eventName = \"ddp-nosub\";\n    var info = _.pick(msg, 'id', 'error');\n    StoreManager.trackTime('pubsub', msg.id, 'nosub');\n    StoreManager.trackEvent(eventName, info);\n\n    original.call(conn, msg);\n  };\n};\nUtils.override(conn, '_livedata_nosub', DDPProvider._livedata_nosub);\n\n// watch outgoing messages\nDDPProvider._send = function(original) {\n  return function(msg) {\n    var info = {};\n    var eventName = null;\n    switch(msg.msg) {\n      case \"method\":\n        if(DDPProvider.ignoringMethods[msg.method]) {\n          DDPProvider.ignoringMethodIds[\"\" + msg.id] = 2;\n          break;\n        }\n        info.name = msg.method;\n        info.id = msg.id;\n        eventName = \"ddp-method\";\n        var timeInfo = {name: msg.method};\n        StoreManager.trackTime('method', msg.id, 'start', timeInfo);\n        break;\n      case \"sub\":\n        info.name = msg.name;\n        info.id = msg.id;\n        eventName = \"ddp-sub\";\n        var timeInfo = {name: msg.name};\n        StoreManager.trackTime('pubsub', msg.id, 'start', timeInfo);\n        break;\n      case \"unsub\":\n        info.id = msg.id;\n        eventName = \"ddp-unsub\";\n        StoreManager.trackTime('pubsub', msg.id, 'unsub');\n        break;\n    }\n\n    if(eventName) {\n      StoreManager.trackEvent(eventName, info);\n    }\n    return original.call(conn, msg);\n  };\n};\nUtils.override(conn, '_send', DDPProvider._send);","// Hot Code Reload Detection\n\nReload._onMigrate('kadiraDebug', function() {\n  Meteor._localStorage.setItem('hcrAt', Date.now());\n  return [true];\n});\n\nvar hcrAt = Meteor._localStorage.getItem('hcrAt');\nif(hcrAt) {\n  hcrAt = parseInt(hcrAt);\n  var elapsedTime = Date.now() - hcrAt;\n  var info = {\n    elapsedTime: elapsedTime\n  };\n  Meteor._localStorage.removeItem('hcrAt');\n\n  // store manager is not started yet. \n  // So we need to run register it to run when it started.\n  StoreManager.startup(function() {\n    StoreManager.trackEvent('hcr', info, hcrAt);\n  });\n}","EventLoopLag = function(timeoutMillis, callback) {\n  function startLoop () {\n    var start = StoreManager.now();\n    setTimeout(function() {\n      var end = StoreManager.now();\n      var lag  = Math.max(0, end - start - timeoutMillis);\n      callback(lag);\n      startLoop();\n    }, timeoutMillis);\n  }\n\n  startLoop();\n};\n\nvar intervalTime = 100;\nvar loopStartTime = Date.now();\nvar totalLag = 0;\nEventLoopLag(intervalTime, function(lag) {\n  totalLag += lag;\n});\n\n// this is a dummy guage tracking to send data\n// to the server always\nsetInterval(function() {\n  StoreManager.trackGuage('dummy', 100);\n}, 500);\n\nStoreManager.beforeBlockClose(function(block) {\n  var now = Date.now();\n  var loopTime = now - loopStartTime;\n  var lagPct = (totalLag/loopTime) * 100;\n\n  block.gauges['eventloop-blockness'] = lagPct;\n  loopStartTime = now;\n  totalLag = 0;\n\n  if(typeof performance !== 'undefined' && performance.memory) {\n    block.gauges['memory'] = performance.memory.usedJSHeapSize;\n  }\n});","KadiraDebug = window.KadiraDebug = {};\nKadiraInfo = new Mongo.Collection('kdInfo');\n\nvar env = Utils.getAppEnv();\n\nvar debug = getQueryParamFromURI('kadira_debug');\nvar accessToken = (debug)? (getQueryParamFromURI('access_token') || null) : null;\n\nif(env === 'production' && !accessToken) {\n  return;\n}\n\nMeteor.subscribe('kadira.debug.client.auth', accessToken, {\n  onReady: function () { \n    // create a unique client for this client\n    // works accross hot code reloads as well\n    var clientId = Session.get('kdClientId');\n    if(!clientId) {\n      clientId = Random.id(8);\n      Session.set('kdClientId', clientId);\n    }\n    KadiraDebug.clientId = clientId;\n\n    // create a unique Id for the browser\n    var browserId = Meteor._localStorage.getItem('kdBrowserId');\n    if(!browserId) {\n      function setName(err, name) {\n        if(err) {\n          browserId = Random.id(8);\n        } else {\n          browserId = name;\n        }\n        Meteor._localStorage.setItem('kdBrowserId', browserId);\n        // invoke the starting process\n        KadiraDebug._init(browserId, clientId);\n      }\n      \n      Meteor.call('kadira.debug.client.getBrowserName', navigator.userAgent, setName);\n    } else {\n      // invoke the starting process\n      KadiraDebug._init(browserId, clientId);\n    }\n  },\n  onStop: function (err) {\n    if(err) {\n      throw new Meteor.Error('401', 'Unauthorized.');\n    } \n  }\n});\n\nKadiraDebug._init = function(browserId, clientId) {\n  // Watch remopte admin listeners for this app.\n  Meteor.subscribe('kadira.debug.client.listeners');\n\n  Meteor.subscribe('kadira.debug.client.init', browserId, clientId);\n  \n  // If there are one or more listeners, then we start the StoreManager\n  // and send data\n  Tracker.autorun(function(c) {\n    var docListeners = KadiraInfo.findOne({_id: \"listeners-count\"});\n    if(docListeners && docListeners.count > 0) {\n      StoreManager.start(browserId, clientId);\n    } else {\n      StoreManager.stop();\n    }\n  });\n};\n\nfunction getQueryParamFromURI(q) {\n  q = q.replace(/[\\[]/, \"\\\\[\").replace(/[\\]]/, \"\\\\]\");\n  var regex = new RegExp(\"[\\\\?&]\" + q + \"=([^&#]*)\"),\n      results = regex.exec(location.search);\n  return results === null ? \"\" : decodeURIComponent(results[1].replace(/\\+/g, \" \"));\n}"]}